import{a as E}from"./index.7a0464ee.js";import{u as x}from"./index.81b98c8b.js";import{p as R,f as v,x as M,a as B,X as D,Y as N,_ as U,u as X,v as F,n as G}from"./ui.64f31f6c.js";import{i as r}from"./i18n.e67af30b.js";const n=200,b=2,j=E("restore",{state:()=>({showRestoreDialog:x("cashu.restore.showRestoreDialog",!1),restoringState:!1,restoringMint:"",mnemonicToRestore:x("cashu.restore.mnemonicToRestore",""),restoreProgress:0,restoreCounter:0,restoreStatus:""}),getters:{},actions:{restoreMint:async function(i){this.restoringState=!0,this.restoringMint=i,this.restoreProgress=0,this.restoreCounter=0,this.restoreStatus="";try{await this._restoreMint(i)}catch(g){R(r.global.t("restore.restore_mint_error_text",{error:g}))}finally{this.restoringState=!1,this.restoringMint="",this.restoreProgress=0}},_restoreMint:async function(i){if(this.mnemonicToRestore.length===0){R(r.global.t("restore.mnemonic_error_text"));return}this.restoreProgress=0;const g=v(),$=M();await B().activateMintUrl(i);const C=this.mnemonicToRestore;this.restoreStatus=r.global.t("restore.prepare_info_text");const d=new D(i),_=(await d.getKeySets()).keysets;let y=!1,h=_.length*b,c=0;for(const e of _){console.log(`Restoring keyset ${e.id} with unit ${e.unit}`);const T=g.mnemonicToSeedSync(C),P=new N(d,{bip39seed:T,unit:e.unit});let l=0,m=0,f=[];for(;m<b;){console.log(`Restoring proofs ${l} to ${l+n}`);const t=(await P.restore(l,n,{keysetId:e.id})).proofs;t.length===0?(console.log(`No proofs found for keyset ${e.id}`),m++):(console.log(`> Restored ${t.length} proofs with sum ${t.reduce((s,p)=>s+p.amount,0)}`),f=f.concat(t),m=0,this.restoreCounter+=t.length,h+=1),this.restoreStatus=r.global.t("restore.restored_proofs_for_keyset_info_text",{restoreCounter:this.restoreCounter,keysetId:e.id}),l+=n,c++,this.restoreProgress=c/h}let S=[];for(let t=0;t<f.length;t+=n){this.restoreStatus=r.global.t("restore.checking_proofs_for_keyset_info_text",{startIndex:t,endIndex:t+n,keysetId:e.id});const s=f.slice(t,t+n),p=await P.checkProofsStates(s),A=s.filter((o,a)=>p[a].state===U.SPENT).map(o=>o.secret),u=s.filter(o=>!A.includes(o.secret));u.length>0&&console.log(`Found ${u.length} unspent proofs with sum ${u.reduce((o,a)=>o+a.amount,0)}`);const k=u.filter(o=>!$.proofs.some(a=>a.secret===o.secret));await M().addProofs(k),S=S.concat(k),c++,this.restoreProgress=c/h}const w=S.reduce((t,s)=>t+s.amount,0),I=X().formatCurrency(w,e.unit);w>0&&(F(r.global.t("restore.restored_amount_success_text",{amount:I})),y=!0)}y||G(r.global.t("restore.no_proofs_info_text"))}}});export{j as u};
