import{a as E}from"./index.51f2b46b.js";import{u as x}from"./branding.c750d619.js";import{p as R,f as v,x as $,b as B,_ as D,$ as N,a0 as U,u as F,v as G,n as H}from"./ui.f9c7454a.js";import{i as r}from"./i18n.79f7761c.js";const n=200,b=2,q=E("restore",{state:()=>({showRestoreDialog:x("cashu.restore.showRestoreDialog",!1),restoringState:!1,restoringMint:"",mnemonicToRestore:x("cashu.restore.mnemonicToRestore",""),restoreProgress:0,restoreCounter:0,restoreStatus:""}),getters:{},actions:{restoreMint:async function(i){this.restoringState=!0,this.restoringMint=i,this.restoreProgress=0,this.restoreCounter=0,this.restoreStatus="";try{await this._restoreMint(i)}catch(g){R(r.global.t("restore.restore_mint_error_text",{error:g}))}finally{this.restoringState=!1,this.restoringMint="",this.restoreProgress=0}},_restoreMint:async function(i){if(this.mnemonicToRestore.length===0){R(r.global.t("restore.mnemonic_error_text"));return}this.restoreProgress=0;const g=v(),M=$();await B().activateMintUrl(i);const C=this.mnemonicToRestore;this.restoreStatus=r.global.t("restore.prepare_info_text");const d=new D(i),_=(await d.getKeySets()).keysets;let y=!1,h=_.length*b,c=0;for(const o of _){console.log(`Restoring keyset ${o.id} with unit ${o.unit}`);const T=g.mnemonicToSeedSync(C),P=new N(d,{bip39seed:T,unit:o.unit});let l=0,m=0,f=[];for(;m<b;){console.log(`Restoring proofs ${l} to ${l+n}`);let e=[];try{e=(await P.restore(l,n,{keysetId:o.id})).proofs}catch(t){console.error(`Error restoring proofs: ${t}`),e=[]}e.length===0?(console.log(`No proofs found for keyset ${o.id}`),m++):(console.log(`> Restored ${e.length} proofs with sum ${e.reduce((t,S)=>t+S.amount,0)}`),f=f.concat(e),m=0,this.restoreCounter+=e.length,h+=1),this.restoreStatus=r.global.t("restore.restored_proofs_for_keyset_info_text",{restoreCounter:this.restoreCounter,keysetId:o.id}),l+=n,c++,this.restoreProgress=c/h}let p=[];for(let e=0;e<f.length;e+=n){this.restoreStatus=r.global.t("restore.checking_proofs_for_keyset_info_text",{startIndex:e,endIndex:e+n,keysetId:o.id});const t=f.slice(e,e+n),S=await P.checkProofsStates(t),A=t.filter((s,a)=>S[a].state===U.SPENT).map(s=>s.secret),u=t.filter(s=>!A.includes(s.secret));u.length>0&&console.log(`Found ${u.length} unspent proofs with sum ${u.reduce((s,a)=>s+a.amount,0)}`);const k=u.filter(s=>!M.proofs.some(a=>a.secret===s.secret));await $().addProofs(k),p=p.concat(k),c++,this.restoreProgress=c/h}const w=p.reduce((e,t)=>e+t.amount,0),I=F().formatCurrency(w,o.unit);w>0&&(G(r.global.t("restore.restored_amount_success_text",{amount:I})),y=!0)}y||H(r.global.t("restore.no_proofs_info_text"))}}});export{q as u};
